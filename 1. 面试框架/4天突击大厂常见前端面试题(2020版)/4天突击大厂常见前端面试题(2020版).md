### 问题
1.生命周期 
beforeCreate =>  created  =>  beforeMount => mounted   
              a            b                c
beforeUpdate =>  updated   
              d                          
beforeDestroy => destroyed
              e

a. 初始化事件，进行数据的观测 ,可以看到在created的时候数据已经和data属性进行绑定 ,此时还是没有el选项;
b.首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el);
c. 给vue实例对象添加$el成员，替换掉挂载的DOM元素;
d. 触发对应组件的重新渲染;
e. 销毁实例。

2.组件通信 
  父子通信props/$emit
  兄弟通信$emit/$on(eventbus)
  vuex
    vuex是一个状态管理机制,采用集中式存储应用所有组件的状态;
    vuex是一种状态管理机制，将全局组件的共享状态抽取出来为一个store，以一个单例模式存在，应用任何一个组件中都可以使用，vuex更改state的唯一途径是通过mutation，mutation需要commit触发, action实际触发是mutation，其中mutation处理同步任务，action处理异步任务;

  $attrs/$listeners
  provide/inject
    简单的来说就是在父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。
    需要注意的是这里不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据。
  $parent / $children与 ref
    

3.双向绑定 
  数据劫持：Object.defineProperty()  
  发布者-订阅者模式：
      Observer 劫持和监听所有属性 
      watcher 收到属性的变化通知并执行相应的函数
      compile 扫描解析每个节点的相关指令
  实现mvvm主要包含两个方面，数据变化更新视图，视图变化更新数据  

4.Nginx的原理 
5.箭头函数 
  箭头函数相当于匿名函数，并且简化了函数定义。

6.性能优化 
       减少http请求
       建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。 
      61. 优化 DOM
          *  删除不必要的代码和注释包括空格，尽量做到最小化文件。
          *  可以利用 GZIP 压缩文件。
          *  结合 HTTP 缓存文件。
      62 . 优化 CSSOM
          CSS 加载会阻塞 Dom 的渲染。
      63 .优化 JavaScript
          浏览器重绘（Repaint）和回流（Reflow）
          避免使用 table 布局。
          尽可能在 DOM 树的最末端改变 class。
          避免设置多层内联样式。
          将动画效果应用到 position 属性为 absolute 或 fixed 的元素上。
          避免使用 CSS 表达式（例如：calc()）。
      图片懒加载
          一个是元素到各个边距的距离，二个就是判断元素是否在可视区域内。
          
      事件委托
        事件委托其实就是利用JS事件冒泡机制把原本需要绑定在子元素的响应事件（click、keydown……）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。

      防抖（debounce）/节流（throttle）
7. webpack打包
8. 调过最难的bug：rancher-ui、  视频流协议的难点 、 跨平台的问题 

最近学习的新技术：
1、不要用到缓存：   服务器ngix配置 、html配置mate头、骨架屏-加载超时出现、
  location / {
  add_header Cache-Control no-cache;
  add_header Pragma no-cache;
  add_header Expires 0;
  }
2、知识点： 浏览器缓存（cache-control、expires、last-modified ETag ) 
           CDN缓存 
const a= {b:1};
a.c 
### 简历点提问
1. fullcalender 
2. 发布-订阅模式/ 观察者模式
  Observer pattern观察者模式 : 为了实现松耦合，每当事件发布，changed()方法被调用，如果把响应事件都写在changed（）里面，就会高度耦合，  而在观察者模式里面，changed（）方法所在的实例对象，就是被观察者，它只需要维护一套观察者模式的集合，这些Observe实现相同的接口，Subject只需要知道，通知Observe时，需要调用哪个统一方法就好了。

  发布-订阅模式：
  在发布订阅模式里，发布者，并不会直接通知订阅者，换句话说，发布者和订阅者，彼此互不相识。

  互不相识？那他们之间如何交流？

  答案是，通过第三者，也就是在消息队列里面，我们常说的经纪人Broker。
  
3.emberjs
4.希望专攻的方向x
5. 多端适配问题：讲一下rem 和px 的原理 
rem是一种尺寸单位，根据根页面html的字号匹配大小。 
首屏优化 



3.3-3.5 next interview
1. mdn文档（every day） css手册（before test） vue文档（every day） 算法基础++++++（every day）
2. frequent tests collection (every day)
3. custom interview simulation (twice )
4. 3 points of deep knowledgement (every day)
5. profile update (every day)
6. create something (every day)

虎牙面试： 
react的了解
前后端跨域问题 
cookie和一些常见的浏览器缓存
调过最难的bug
性能优化的实例
安全方面的问题
  使用https协议的通信，自动打开secure
组件的动态加载
线上的问题收集？


1. 如何看待日活pv千万级别的开发
2. 如何培训初级前端
3. 钱大妈商城页面的图片样式懒加载
4. 公司通用组件使用  smartData 数据BI与SQL对接


亿阳：
  1. rem  em的区别
  2. webpack 打包优化
  Nginx配置
  es6的新增属性
  


