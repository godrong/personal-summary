##### 简单来说就是网站的速度够不够快。
    - 打开速度
    - 动画效果
    - 表单提交
    - 列表滚动
    - 页面切换
---
    MDN的定义： **Web性能是网站或者应用程序的客观度量和可感知的用户体验。**
减少整体加载时间： 减少文件体积，减少HTTP请求，使用预加载；
使网站尽快可用： 仅加载首屏内容，其他内容根据需要进行懒加载；
平滑和交互性： 使用css替代js动画，减少UI重绘；
感知表现： 你的页面可能不能做的更快，但你可以让用户感觉很快，耗时操作要给用户反馈，比如加载动画，进度条，骨架屏等提示信息；
性能测定： 性能指标、性能测试、性能监控持续优化。

### 基于用户体验的性能指标

1. First Contentful Paint (FCP 白屏时间) 浏览器首次绘制DOM的时间
  0-2s 75-100分
2. Largest Contentful Paint (LCP 最大内容加载) 
    2.5s 75-100
3.  FID
   100ms以内  
4.  TTI 网页第一次到能够完全交互的时间 time to  interactive
5.  CLS  Cumulative Layout Shift 页面布局稳定性


#### 从输入url到生成可用页面
    DNS解析-
        dns-prefetch（提前加载跨域的dns资源） 仅对跨域域上的DNS查找有效
    HTTP1.1-
        默认长连接
        管道机制 同时并发多个请求
        content-length字段 声明本次回应的数据长度 比如规定长度2019 后面的长度就是下一个数据的长度了
        Transfer-Encoding：chunked 分块传输编码 回应将由数量未定的数据块构成
        长连接的缺陷- 队头阻塞
            解决方案：1. 减少请求数； 2.同时多开持久连接。
    HTTP/2-
        二进制协议- 头信息和数据体都是二进制 ，并且统称为帧： 头信息帧和数据帧
        多工 -  双向的实时通信，在一个连接里，客户端和浏览器都可以同时发送多个请求或者回应，而且不按照顺序一一对应，避免了对头阻塞。
        数据流 -对请求和响应的数据包进行标记，分配唯一的ID，其中客户端为奇数，服务器为偶数；（还可以半途取消）
        头信息压缩- gzip压缩重复的头信息，建立头信息的索引表，提高下次访问的速度。
        服务器推送- 主动向客户端发送资源。
    HTTP强制缓存和协商缓存   Last-Modified ETag    

##### 平滑和交互性
    减少回流和重绘
    1.1 回流
        前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要**计算它们在设备视口(viewport)内的确切位置和大小**，这个计算的阶段就是回流。
    1.2 重绘
        最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以**将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点**。
    1.3 什么时候发生？
        添加或删除可见的DOM元素
        元素的位置发生变化
        元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
        内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
        页面一开始渲染的时候（这肯定避免不了）
        浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的） 
    1.4 如何避免？
        a> 浏览器的优化机制-减少获取布局信息的操作，如
            offsetTop、offsetLeft、offsetWidth、offsetHeight
            scrollTop、scrollLeft、scrollWidth、scrollHeight
            clientTop、clientLeft、clientWidth、clientHeight
            getComputedStyle()
            getBoundingClientRect     
        b> 最小化重绘和重排，合并多次对DOM和样式的修改，然后一次处理掉 ,采用class代替js操作dom；
        c> 批量修改DOM
            方式1: 隐藏元素，应用修改，重新显示
            方式2：使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档
            方式3：将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。   
        d> 避免触发同步布局事件
        e> 对于复杂动画效果,使用绝对定位让其脱离文档流 
        f> css3硬件加速（GPU加速）
        g> requestAnimationFrame 代替 setTimeout、setInterval做定时请求。(你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行 MDN)